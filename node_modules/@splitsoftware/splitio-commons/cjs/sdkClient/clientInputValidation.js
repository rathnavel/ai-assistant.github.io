"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientInputValidationDecorator = void 0;
var objectAssign_1 = require("../utils/lang/objectAssign");
var inputValidation_1 = require("../utils/inputValidation");
var lang_1 = require("../utils/lang");
var constants_1 = require("../utils/constants");
var mode_1 = require("../utils/settingsValidation/mode");
var splitFilters_1 = require("../utils/settingsValidation/splitFilters");
/**
 * Decorator that validates the input before actually executing the client methods.
 * We should "guard" the client here, while not polluting the "real" implementation of those methods.
 */
function clientInputValidationDecorator(settings, client, readinessManager) {
    var log = settings.log, mode = settings.mode;
    var isAsync = (0, mode_1.isConsumerMode)(mode);
    /**
     * Avoid repeating this validations code
     */
    function validateEvaluationParams(maybeKey, maybeNameOrNames, maybeAttributes, methodName) {
        var key = (0, inputValidation_1.validateKey)(log, maybeKey, methodName);
        var nameOrNames = methodName.indexOf('ByFlagSet') > -1 ?
            (0, splitFilters_1.validateFlagSets)(log, methodName, maybeNameOrNames, settings.sync.__splitFiltersValidation.groupedFilters.bySet) :
            (0, lang_1.startsWith)(methodName, constants_1.GET_TREATMENTS) ?
                (0, inputValidation_1.validateSplits)(log, maybeNameOrNames, methodName) :
                (0, inputValidation_1.validateSplit)(log, maybeNameOrNames, methodName);
        var attributes = (0, inputValidation_1.validateAttributes)(log, maybeAttributes, methodName);
        var isNotDestroyed = (0, inputValidation_1.validateIfNotDestroyed)(log, readinessManager, methodName);
        (0, inputValidation_1.validateIfOperational)(log, readinessManager, methodName, nameOrNames);
        var valid = isNotDestroyed && key && nameOrNames && attributes !== false;
        return {
            valid: valid,
            key: key,
            nameOrNames: nameOrNames,
            attributes: attributes
        };
    }
    function wrapResult(value) {
        return isAsync ? Promise.resolve(value) : value;
    }
    function getTreatment(maybeKey, maybeFeatureFlagName, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagName, maybeAttributes, constants_1.GET_TREATMENT);
        if (params.valid) {
            return client.getTreatment(params.key, params.nameOrNames, params.attributes);
        }
        else {
            return wrapResult(constants_1.CONTROL);
        }
    }
    function getTreatmentWithConfig(maybeKey, maybeFeatureFlagName, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagName, maybeAttributes, constants_1.GET_TREATMENT_WITH_CONFIG);
        if (params.valid) {
            return client.getTreatmentWithConfig(params.key, params.nameOrNames, params.attributes);
        }
        else {
            return wrapResult((0, objectAssign_1.objectAssign)({}, constants_1.CONTROL_WITH_CONFIG));
        }
    }
    function getTreatments(maybeKey, maybeFeatureFlagNames, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagNames, maybeAttributes, constants_1.GET_TREATMENTS);
        if (params.valid) {
            return client.getTreatments(params.key, params.nameOrNames, params.attributes);
        }
        else {
            var res_1 = {};
            if (params.nameOrNames)
                params.nameOrNames.forEach(function (split) { return res_1[split] = constants_1.CONTROL; });
            return wrapResult(res_1);
        }
    }
    function getTreatmentsWithConfig(maybeKey, maybeFeatureFlagNames, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagNames, maybeAttributes, constants_1.GET_TREATMENTS_WITH_CONFIG);
        if (params.valid) {
            return client.getTreatmentsWithConfig(params.key, params.nameOrNames, params.attributes);
        }
        else {
            var res_2 = {};
            if (params.nameOrNames)
                params.nameOrNames.forEach(function (split) { return res_2[split] = (0, objectAssign_1.objectAssign)({}, constants_1.CONTROL_WITH_CONFIG); });
            return wrapResult(res_2);
        }
    }
    function getTreatmentsByFlagSets(maybeKey, maybeFlagSets, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFlagSets, maybeAttributes, constants_1.GET_TREATMENTS_BY_FLAG_SETS);
        if (params.valid) {
            return client.getTreatmentsByFlagSets(params.key, params.nameOrNames, params.attributes);
        }
        else {
            return wrapResult({});
        }
    }
    function getTreatmentsWithConfigByFlagSets(maybeKey, maybeFlagSets, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFlagSets, maybeAttributes, constants_1.GET_TREATMENTS_WITH_CONFIG_BY_FLAG_SETS);
        if (params.valid) {
            return client.getTreatmentsWithConfigByFlagSets(params.key, params.nameOrNames, params.attributes);
        }
        else {
            return wrapResult({});
        }
    }
    function getTreatmentsByFlagSet(maybeKey, maybeFlagSet, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, [maybeFlagSet], maybeAttributes, constants_1.GET_TREATMENTS_BY_FLAG_SET);
        if (params.valid) {
            return client.getTreatmentsByFlagSet(params.key, params.nameOrNames[0], params.attributes);
        }
        else {
            return wrapResult({});
        }
    }
    function getTreatmentsWithConfigByFlagSet(maybeKey, maybeFlagSet, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, [maybeFlagSet], maybeAttributes, constants_1.GET_TREATMENTS_WITH_CONFIG_BY_FLAG_SET);
        if (params.valid) {
            return client.getTreatmentsWithConfigByFlagSet(params.key, params.nameOrNames[0], params.attributes);
        }
        else {
            return wrapResult({});
        }
    }
    function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {
        var key = (0, inputValidation_1.validateKey)(log, maybeKey, constants_1.TRACK_FN_LABEL);
        var tt = (0, inputValidation_1.validateTrafficType)(log, maybeTT, constants_1.TRACK_FN_LABEL);
        var event = (0, inputValidation_1.validateEvent)(log, maybeEvent, constants_1.TRACK_FN_LABEL);
        var eventValue = (0, inputValidation_1.validateEventValue)(log, maybeEventValue, constants_1.TRACK_FN_LABEL);
        var _a = (0, inputValidation_1.validateEventProperties)(log, maybeProperties, constants_1.TRACK_FN_LABEL), properties = _a.properties, size = _a.size;
        var isNotDestroyed = (0, inputValidation_1.validateIfNotDestroyed)(log, readinessManager, constants_1.TRACK_FN_LABEL);
        if (isNotDestroyed && key && tt && event && eventValue !== false && properties !== false) { // @ts-expect-error
            return client.track(key, tt, event, eventValue, properties, size);
        }
        else {
            return isAsync ? Promise.resolve(false) : false;
        }
    }
    return {
        getTreatment: getTreatment,
        getTreatmentWithConfig: getTreatmentWithConfig,
        getTreatments: getTreatments,
        getTreatmentsWithConfig: getTreatmentsWithConfig,
        getTreatmentsByFlagSets: getTreatmentsByFlagSets,
        getTreatmentsWithConfigByFlagSets: getTreatmentsWithConfigByFlagSets,
        getTreatmentsByFlagSet: getTreatmentsByFlagSet,
        getTreatmentsWithConfigByFlagSet: getTreatmentsWithConfigByFlagSet,
        track: track
    };
}
exports.clientInputValidationDecorator = clientInputValidationDecorator;
