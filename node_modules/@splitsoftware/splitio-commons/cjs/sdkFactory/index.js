"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sdkFactory = void 0;
var sdkReadinessManager_1 = require("../readiness/sdkReadinessManager");
var impressionsTracker_1 = require("../trackers/impressionsTracker");
var eventTracker_1 = require("../trackers/eventTracker");
var telemetryTracker_1 = require("../trackers/telemetryTracker");
var apiKey_1 = require("../utils/inputValidation/apiKey");
var sdkLogger_1 = require("../logger/sdkLogger");
var constants_1 = require("../logger/constants");
var constants_2 = require("../readiness/constants");
var objectAssign_1 = require("../utils/lang/objectAssign");
var strategyDebug_1 = require("../trackers/strategy/strategyDebug");
var strategyOptimized_1 = require("../trackers/strategy/strategyOptimized");
var strategyNone_1 = require("../trackers/strategy/strategyNone");
var uniqueKeysTracker_1 = require("../trackers/uniqueKeysTracker");
var constants_3 = require("../utils/constants");
/**
 * Modular SDK factory
 */
function sdkFactory(params) {
    var settings = params.settings, platform = params.platform, storageFactory = params.storageFactory, splitApiFactory = params.splitApiFactory, extraProps = params.extraProps, syncManagerFactory = params.syncManagerFactory, SignalListener = params.SignalListener, impressionsObserverFactory = params.impressionsObserverFactory, integrationsManagerFactory = params.integrationsManagerFactory, sdkManagerFactory = params.sdkManagerFactory, sdkClientMethodFactory = params.sdkClientMethodFactory, filterAdapterFactory = params.filterAdapterFactory;
    var log = settings.log, impressionsMode = settings.sync.impressionsMode;
    // @TODO handle non-recoverable errors, such as, global `fetch` not available, invalid SDK Key, etc.
    // On non-recoverable errors, we should mark the SDK as destroyed and not start synchronization.
    // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.
    (0, apiKey_1.validateAndTrackApiKey)(log, settings.core.authorizationKey);
    var sdkReadinessManager = (0, sdkReadinessManager_1.sdkReadinessManagerFactory)(log, platform.EventEmitter, settings.startup.readyTimeout);
    var readiness = sdkReadinessManager.readinessManager;
    var storage = storageFactory({
        settings: settings,
        onReadyCb: function (error) {
            if (error) {
                // If storage fails to connect, SDK_READY_TIMED_OUT event is emitted immediately. Review when timeout and non-recoverable errors are reworked
                readiness.timeout();
                return;
            }
            readiness.splits.emit(constants_2.SDK_SPLITS_ARRIVED);
            readiness.segments.emit(constants_2.SDK_SEGMENTS_ARRIVED);
        },
    });
    // @TODO add support for dataloader: `if (params.dataLoader) params.dataLoader(storage);`
    var telemetryTracker = (0, telemetryTracker_1.telemetryTrackerFactory)(storage.telemetry, platform.now);
    var integrationsManager = integrationsManagerFactory && integrationsManagerFactory({ settings: settings, storage: storage, telemetryTracker: telemetryTracker });
    var observer = impressionsObserverFactory();
    var uniqueKeysTracker = impressionsMode === constants_3.NONE ? (0, uniqueKeysTracker_1.uniqueKeysTrackerFactory)(log, storage.uniqueKeys, filterAdapterFactory && filterAdapterFactory()) : undefined;
    var strategy;
    switch (impressionsMode) {
        case constants_3.OPTIMIZED:
            strategy = (0, strategyOptimized_1.strategyOptimizedFactory)(observer, storage.impressionCounts);
            break;
        case constants_3.NONE:
            strategy = (0, strategyNone_1.strategyNoneFactory)(storage.impressionCounts, uniqueKeysTracker);
            break;
        default:
            strategy = (0, strategyDebug_1.strategyDebugFactory)(observer);
    }
    var impressionsTracker = (0, impressionsTracker_1.impressionsTrackerFactory)(settings, storage.impressions, strategy, integrationsManager, storage.telemetry);
    var eventTracker = (0, eventTracker_1.eventTrackerFactory)(settings, storage.events, integrationsManager, storage.telemetry);
    // splitApi is used by SyncManager and Browser signal listener
    var splitApi = splitApiFactory && splitApiFactory(settings, platform, telemetryTracker);
    var ctx = { splitApi: splitApi, eventTracker: eventTracker, impressionsTracker: impressionsTracker, telemetryTracker: telemetryTracker, uniqueKeysTracker: uniqueKeysTracker, sdkReadinessManager: sdkReadinessManager, readiness: readiness, settings: settings, storage: storage, platform: platform };
    var syncManager = syncManagerFactory && syncManagerFactory(ctx);
    ctx.syncManager = syncManager;
    var signalListener = SignalListener && new SignalListener(syncManager, settings, storage, splitApi);
    ctx.signalListener = signalListener;
    // SDK client and manager
    var clientMethod = sdkClientMethodFactory(ctx);
    var managerInstance = sdkManagerFactory(settings, storage.splits, sdkReadinessManager);
    syncManager && syncManager.start();
    signalListener && signalListener.start();
    log.info(constants_1.NEW_FACTORY);
    // @ts-ignore
    return (0, objectAssign_1.objectAssign)({
        // Split evaluation and event tracking engine
        client: clientMethod,
        // Manager API to explore available information
        manager: function () {
            log.debug(constants_1.RETRIEVE_MANAGER);
            return managerInstance;
        },
        // Logger wrapper API
        Logger: (0, sdkLogger_1.createLoggerAPI)(log),
        settings: settings,
    }, extraProps && extraProps(ctx));
}
exports.sdkFactory = sdkFactory;
