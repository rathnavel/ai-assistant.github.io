"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchersTransform = void 0;
var lang_1 = require("../../utils/lang");
var matcherTypes_1 = require("../matchers/matcherTypes");
var segment_1 = require("./segment");
var whitelist_1 = require("./whitelist");
var unaryNumeric_1 = require("./unaryNumeric");
var convertions_1 = require("../convertions");
/**
 * Flat the complex matcherGroup structure into something handy.
 */
function matchersTransform(matchers) {
    var parsedMatchers = matchers.map(function (matcher) {
        var matcherType = matcher.matcherType, negate = matcher.negate, keySelector = matcher.keySelector, userDefinedSegmentMatcherData = matcher.userDefinedSegmentMatcherData, whitelistMatcherData = matcher.whitelistMatcherData, /* whitelistObject, provided by 'WHITELIST', 'IN_LIST_SEMVER', set and string matchers */ unaryNumericMatcherData = matcher.unaryNumericMatcherData, betweenMatcherData = matcher.betweenMatcherData, dependencyMatcherData = matcher.dependencyMatcherData, booleanMatcherData = matcher.booleanMatcherData, stringMatcherData = matcher.stringMatcherData, betweenStringMatcherData = matcher.betweenStringMatcherData;
        var attribute = keySelector && keySelector.attribute;
        var type = (0, matcherTypes_1.matcherTypesMapper)(matcherType);
        // As default input data type we use string (even for ALL_KEYS)
        var dataType = matcherTypes_1.matcherDataTypes.STRING;
        var value = undefined;
        if (type === matcherTypes_1.matcherTypes.IN_SEGMENT) {
            value = (0, segment_1.segmentTransform)(userDefinedSegmentMatcherData);
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO) {
            value = (0, unaryNumeric_1.numericTransform)(unaryNumericMatcherData);
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (unaryNumericMatcherData.dataType === 'DATETIME') {
                value = (0, convertions_1.zeroSinceHH)(value);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.GREATER_THAN_OR_EQUAL_TO ||
            type === matcherTypes_1.matcherTypes.LESS_THAN_OR_EQUAL_TO) {
            value = (0, unaryNumeric_1.numericTransform)(unaryNumericMatcherData);
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (unaryNumericMatcherData.dataType === 'DATETIME') {
                value = (0, convertions_1.zeroSinceSS)(value);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.BETWEEN) {
            value = betweenMatcherData;
            dataType = matcherTypes_1.matcherDataTypes.NUMBER;
            if (value.dataType === 'DATETIME') {
                value.start = (0, convertions_1.zeroSinceSS)(value.start);
                value.end = (0, convertions_1.zeroSinceSS)(value.end);
                dataType = matcherTypes_1.matcherDataTypes.DATETIME;
            }
        }
        else if (type === matcherTypes_1.matcherTypes.BETWEEN_SEMVER) {
            value = betweenStringMatcherData;
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO_SET ||
            type === matcherTypes_1.matcherTypes.CONTAINS_ANY_OF_SET ||
            type === matcherTypes_1.matcherTypes.CONTAINS_ALL_OF_SET ||
            type === matcherTypes_1.matcherTypes.PART_OF_SET) {
            value = (0, whitelist_1.whitelistTransform)(whitelistMatcherData);
            dataType = matcherTypes_1.matcherDataTypes.SET;
        }
        else if (type === matcherTypes_1.matcherTypes.WHITELIST ||
            type === matcherTypes_1.matcherTypes.IN_LIST_SEMVER ||
            type === matcherTypes_1.matcherTypes.STARTS_WITH ||
            type === matcherTypes_1.matcherTypes.ENDS_WITH ||
            type === matcherTypes_1.matcherTypes.CONTAINS_STRING) {
            value = (0, whitelist_1.whitelistTransform)(whitelistMatcherData);
        }
        else if (type === matcherTypes_1.matcherTypes.IN_SPLIT_TREATMENT) {
            value = dependencyMatcherData;
            dataType = matcherTypes_1.matcherDataTypes.NOT_SPECIFIED;
        }
        else if (type === matcherTypes_1.matcherTypes.EQUAL_TO_BOOLEAN) {
            dataType = matcherTypes_1.matcherDataTypes.BOOLEAN;
            value = booleanMatcherData;
        }
        else if (type === matcherTypes_1.matcherTypes.MATCHES_STRING ||
            type === matcherTypes_1.matcherTypes.EQUAL_TO_SEMVER ||
            type === matcherTypes_1.matcherTypes.GREATER_THAN_OR_EQUAL_TO_SEMVER ||
            type === matcherTypes_1.matcherTypes.LESS_THAN_OR_EQUAL_TO_SEMVER) {
            value = stringMatcherData;
        }
        return {
            attribute: attribute,
            negate: negate,
            type: type,
            name: matcherType,
            value: value,
            dataType: dataType // runtime input data type
        };
    });
    if ((0, lang_1.findIndex)(parsedMatchers, function (m) { return m.type === matcherTypes_1.matcherTypes.UNDEFINED; }) === -1) {
        return parsedMatchers;
    }
    else {
        return [];
    }
}
exports.matchersTransform = matchersTransform;
