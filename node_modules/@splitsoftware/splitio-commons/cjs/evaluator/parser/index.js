"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parser = void 0;
var matchersTransform_1 = require("../matchersTransform");
var treatments_1 = require("../treatments");
var matchers_1 = require("../matchers");
var value_1 = require("../value");
var condition_1 = require("../condition");
var ifelseif_1 = require("../combiners/ifelseif");
var and_1 = require("../combiners/and");
var thenable_1 = require("../../utils/promise/thenable");
var constants_1 = require("../../logger/constants");
function parser(log, conditions, storage) {
    var predicates = [];
    for (var i = 0; i < conditions.length; i++) {
        var _a = conditions[i], matcherGroup = _a.matcherGroup, partitions = _a.partitions, label = _a.label, conditionType = _a.conditionType;
        // transform data structure
        var matchers = (0, matchersTransform_1.matchersTransform)(matcherGroup.matchers);
        // create a set of pure functions from the matcher's dto
        var expressions = matchers.map(function (matcherDto) {
            var matcher;
            try {
                matcher = (0, matchers_1.matcherFactory)(log, matcherDto, storage);
            }
            catch (error) {
                log.error(constants_1.ENGINE_MATCHER_ERROR, [matcherDto.name, error]);
            }
            // Evaluator function.
            return function (key, attributes, splitEvaluator) {
                var value = (0, value_1.sanitizeValue)(log, key, matcherDto, attributes);
                var result = false;
                if (value !== undefined && matcher) {
                    try {
                        result = matcher(value, splitEvaluator);
                    }
                    catch (error) {
                        log.error(constants_1.ENGINE_MATCHER_ERROR, [matcherDto.name, error]);
                    }
                }
                function handleResult(result) {
                    log.debug(constants_1.ENGINE_MATCHER_RESULT, [matcherDto.name, result, matcherDto.value, value]); // @ts-ignore
                    return Boolean(result ^ matcherDto.negate);
                }
                return (0, thenable_1.thenable)(result) ?
                    result.then(handleResult) :
                    handleResult(result);
            };
        });
        // if matcher's factory can't instantiate the matchers, the expressions array will be empty
        if (expressions.length === 0) {
            // reset any data collected during parsing
            predicates = [];
            // and break the loop
            break;
        }
        predicates.push((0, condition_1.conditionContext)(log, (0, and_1.andCombinerContext)(log, expressions), treatments_1.Treatments.parse(partitions), label, conditionType));
    }
    // Instanciate evaluator given the set of conditions using if else if logic
    return (0, ifelseif_1.ifElseIfCombinerContext)(log, predicates);
}
exports.parser = parser;
