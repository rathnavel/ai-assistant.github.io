"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniqueKeysCachePluggable = void 0;
var tslib_1 = require("tslib");
var UniqueKeysCacheInMemory_1 = require("../inMemory/UniqueKeysCacheInMemory");
var sets_1 = require("../../utils/lang/sets");
var constants_1 = require("../inRedis/constants");
var constants_2 = require("./constants");
var UniqueKeysCachePluggable = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(UniqueKeysCachePluggable, _super);
    function UniqueKeysCachePluggable(log, key, wrapper, uniqueKeysQueueSize, refreshRate) {
        if (uniqueKeysQueueSize === void 0) { uniqueKeysQueueSize = constants_1.DEFAULT_CACHE_SIZE; }
        if (refreshRate === void 0) { refreshRate = constants_1.REFRESH_RATE; }
        var _this = _super.call(this, uniqueKeysQueueSize) || this;
        _this.log = log;
        _this.key = key;
        _this.wrapper = wrapper;
        _this.refreshRate = refreshRate;
        _this.onFullQueue = function () { _this.storeUniqueKeys(); };
        return _this;
    }
    UniqueKeysCachePluggable.prototype.storeUniqueKeys = function () {
        var _this = this;
        var featureNames = Object.keys(this.uniqueKeysTracker);
        if (!featureNames.length)
            return Promise.resolve(false);
        var uniqueKeysArray = featureNames.map(function (featureName) {
            var featureKeys = (0, sets_1.setToArray)(_this.uniqueKeysTracker[featureName]);
            var uniqueKeysPayload = {
                f: featureName,
                ks: featureKeys
            };
            return JSON.stringify(uniqueKeysPayload);
        });
        this.clear();
        return this.wrapper.pushItems(this.key, uniqueKeysArray)
            .catch(function (err) {
            _this.log.error(constants_2.LOG_PREFIX + "Error in uniqueKeys pipeline: " + err + ".");
            return false;
        });
    };
    UniqueKeysCachePluggable.prototype.start = function () {
        this.intervalId = setInterval(this.storeUniqueKeys.bind(this), this.refreshRate);
    };
    UniqueKeysCachePluggable.prototype.stop = function () {
        clearInterval(this.intervalId);
        return this.storeUniqueKeys();
    };
    /**
     * Async consumer API, used by synchronizer.
     * @param count number of items to pop from the queue. If not provided or equal 0, all items will be popped.
     */
    UniqueKeysCachePluggable.prototype.popNRaw = function (count) {
        var _this = this;
        if (count === void 0) { count = 0; }
        return Promise.resolve(count || this.wrapper.getItemsCount(this.key))
            .then(function (count) { return _this.wrapper.popItems(_this.key, count); })
            .then(function (uniqueKeyItems) { return uniqueKeyItems.map(function (uniqueKeyItem) { return JSON.parse(uniqueKeyItem); }); });
    };
    return UniqueKeysCachePluggable;
}(UniqueKeysCacheInMemory_1.UniqueKeysCacheInMemory));
exports.UniqueKeysCachePluggable = UniqueKeysCachePluggable;
