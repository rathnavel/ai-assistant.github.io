"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryCachePluggable = void 0;
var findLatencyIndex_1 = require("../findLatencyIndex");
var telemetrySubmitter_1 = require("../../sync/submitters/telemetrySubmitter");
var constants_1 = require("../../utils/constants");
var lang_1 = require("../../utils/lang");
var maps_1 = require("../../utils/lang/maps");
var TelemetryCacheInMemory_1 = require("../inMemory/TelemetryCacheInMemory");
var utils_1 = require("../utils");
var TelemetryCachePluggable = /** @class */ (function () {
    /**
     * Create a Telemetry cache that uses a storage wrapper.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param wrapper  Adapted wrapper storage.
     */
    function TelemetryCachePluggable(log, keys, wrapper) {
        this.log = log;
        this.keys = keys;
        this.wrapper = wrapper;
    }
    TelemetryCachePluggable.prototype.recordLatency = function (method, latencyMs) {
        return this.wrapper.incr(this.keys.buildLatencyKey(method, (0, findLatencyIndex_1.findLatencyIndex)(latencyMs)))
            .catch(function () { });
    };
    TelemetryCachePluggable.prototype.recordException = function (method) {
        return this.wrapper.incr(this.keys.buildExceptionKey(method))
            .catch(function () { });
    };
    TelemetryCachePluggable.prototype.recordConfig = function () {
        var value = JSON.stringify((0, telemetrySubmitter_1.getTelemetryConfigStats)(constants_1.CONSUMER_MODE, constants_1.STORAGE_PLUGGABLE));
        return this.wrapper.set(this.keys.buildInitKey(), value).catch(function () { });
    };
    /**
     * Pop telemetry latencies.
     * The returned promise rejects if wrapper operations fail.
     */
    TelemetryCachePluggable.prototype.popLatencies = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.keys.latencyPrefix).then(function (latencyKeys) {
            return latencyKeys.length ?
                _this.wrapper.getMany(latencyKeys).then(function (latencies) {
                    var result = new maps_1._Map();
                    for (var i = 0; i < latencyKeys.length; i++) {
                        var field = latencyKeys[i].split('::')[1];
                        var parsedField = (0, utils_1.parseLatencyField)(field);
                        if ((0, lang_1.isString)(parsedField)) {
                            _this.log.error("Ignoring invalid latency field: " + field + ": " + parsedField);
                            continue;
                        }
                        // @ts-ignore
                        var count = parseInt(latencies[i]);
                        if ((0, lang_1.isNaNNumber)(count)) {
                            _this.log.error("Ignoring latency with invalid count: " + latencies[i]);
                            continue;
                        }
                        var metadata = parsedField[0], method = parsedField[1], bucket = parsedField[2];
                        if (bucket >= TelemetryCacheInMemory_1.MAX_LATENCY_BUCKET_COUNT) {
                            _this.log.error("Ignoring latency with invalid bucket: " + bucket);
                            continue;
                        }
                        var methodLatencies = result.get(metadata) || {};
                        methodLatencies[method] = methodLatencies[method] || (0, TelemetryCacheInMemory_1.newBuckets)();
                        methodLatencies[method][bucket] = count;
                        result.set(metadata, methodLatencies);
                    }
                    return Promise.all(latencyKeys.map(function (latencyKey) { return _this.wrapper.del(latencyKey); })).then(function () { return result; });
                }) :
                // If latencyKeys is empty, return an empty map.
                new maps_1._Map();
        });
    };
    /**
     * Pop telemetry exceptions.
     * The returned promise rejects if wrapper operations fail.
     */
    TelemetryCachePluggable.prototype.popExceptions = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.keys.exceptionPrefix).then(function (exceptionKeys) {
            return exceptionKeys.length ?
                _this.wrapper.getMany(exceptionKeys).then(function (exceptions) {
                    var result = new maps_1._Map();
                    for (var i = 0; i < exceptionKeys.length; i++) {
                        var field = exceptionKeys[i].split('::')[1];
                        var parsedField = (0, utils_1.parseExceptionField)(field);
                        if ((0, lang_1.isString)(parsedField)) {
                            _this.log.error("Ignoring invalid exception field: " + field + ": " + parsedField);
                            continue;
                        }
                        // @ts-ignore
                        var count = parseInt(exceptions[i]);
                        if ((0, lang_1.isNaNNumber)(count)) {
                            _this.log.error("Ignoring exception with invalid count: " + exceptions[i]);
                            continue;
                        }
                        var metadata = parsedField[0], method = parsedField[1];
                        if (!result.has(metadata))
                            result.set(metadata, {});
                        result.get(metadata)[method] = count;
                    }
                    return Promise.all(exceptionKeys.map(function (exceptionKey) { return _this.wrapper.del(exceptionKey); })).then(function () { return result; });
                }) :
                // If exceptionKeys is empty, return an empty map.
                new maps_1._Map();
        });
    };
    /**
     * Pop telemetry configs.
     * The returned promise rejects if wrapper operations fail.
     */
    TelemetryCachePluggable.prototype.popConfigs = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.keys.initPrefix).then(function (configKeys) {
            return configKeys.length ?
                _this.wrapper.getMany(configKeys).then(function (configs) {
                    var result = new maps_1._Map();
                    for (var i = 0; i < configKeys.length; i++) {
                        var field = configKeys[i].split('::')[1];
                        var parsedField = (0, utils_1.parseMetadata)(field);
                        if ((0, lang_1.isString)(parsedField)) {
                            _this.log.error("Ignoring invalid config field: " + field + ": " + parsedField);
                            continue;
                        }
                        var metadata = parsedField[0];
                        try { // @ts-ignore
                            var config = JSON.parse(configs[i]);
                            result.set(metadata, config);
                        }
                        catch (e) {
                            _this.log.error("Ignoring invalid config: " + configs[i]);
                        }
                    }
                    return Promise.all(configKeys.map(function (configKey) { return _this.wrapper.del(configKey); })).then(function () { return result; });
                }) :
                // If configKeys is empty, return an empty map.
                new maps_1._Map();
        });
    };
    return TelemetryCachePluggable;
}());
exports.TelemetryCachePluggable = TelemetryCachePluggable;
