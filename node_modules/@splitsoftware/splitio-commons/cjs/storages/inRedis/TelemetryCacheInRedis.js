"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryCacheInRedis = void 0;
var findLatencyIndex_1 = require("../findLatencyIndex");
var telemetrySubmitter_1 = require("../../sync/submitters/telemetrySubmitter");
var constants_1 = require("../../utils/constants");
var lang_1 = require("../../utils/lang");
var maps_1 = require("../../utils/lang/maps");
var TelemetryCacheInMemory_1 = require("../inMemory/TelemetryCacheInMemory");
var utils_1 = require("../utils");
var TelemetryCacheInRedis = /** @class */ (function () {
    /**
     * Create a Telemetry cache that uses Redis as storage.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param redis  Redis client.
     */
    function TelemetryCacheInRedis(log, keys, redis) {
        this.log = log;
        this.keys = keys;
        this.redis = redis;
    }
    TelemetryCacheInRedis.prototype.recordLatency = function (method, latencyMs) {
        var _a = this.keys.buildLatencyKey(method, (0, findLatencyIndex_1.findLatencyIndex)(latencyMs)).split('::'), key = _a[0], field = _a[1];
        return this.redis.hincrby(key, field, 1)
            .catch(function () { });
    };
    TelemetryCacheInRedis.prototype.recordException = function (method) {
        var _a = this.keys.buildExceptionKey(method).split('::'), key = _a[0], field = _a[1];
        return this.redis.hincrby(key, field, 1)
            .catch(function () { });
    };
    TelemetryCacheInRedis.prototype.recordConfig = function () {
        var _a = this.keys.buildInitKey().split('::'), key = _a[0], field = _a[1];
        var value = JSON.stringify((0, telemetrySubmitter_1.getTelemetryConfigStats)(constants_1.CONSUMER_MODE, constants_1.STORAGE_REDIS));
        return this.redis.hset(key, field, value).catch(function () { });
    };
    /**
     * Pop telemetry latencies.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popLatencies = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.latencyPrefix).then(function (latencies) {
            var result = new maps_1._Map();
            Object.keys(latencies).forEach(function (field) {
                var parsedField = (0, utils_1.parseLatencyField)(field);
                if ((0, lang_1.isString)(parsedField)) {
                    _this.log.error("Ignoring invalid latency field: " + field + ": " + parsedField);
                    return;
                }
                var count = parseInt(latencies[field]);
                if ((0, lang_1.isNaNNumber)(count)) {
                    _this.log.error("Ignoring latency with invalid count: " + latencies[field]);
                    return;
                }
                var metadata = parsedField[0], method = parsedField[1], bucket = parsedField[2];
                if (bucket >= TelemetryCacheInMemory_1.MAX_LATENCY_BUCKET_COUNT) {
                    _this.log.error("Ignoring latency with invalid bucket: " + bucket);
                    return;
                }
                var methodLatencies = result.get(metadata) || {};
                methodLatencies[method] = methodLatencies[method] || (0, TelemetryCacheInMemory_1.newBuckets)();
                methodLatencies[method][bucket] = count;
                result.set(metadata, methodLatencies);
            });
            return _this.redis.del(_this.keys.latencyPrefix).then(function () { return result; });
        });
    };
    /**
     * Pop telemetry exceptions.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popExceptions = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.exceptionPrefix).then(function (exceptions) {
            var result = new maps_1._Map();
            Object.keys(exceptions).forEach(function (field) {
                var parsedField = (0, utils_1.parseExceptionField)(field);
                if ((0, lang_1.isString)(parsedField)) {
                    _this.log.error("Ignoring invalid exception field: " + field + ": " + parsedField);
                    return;
                }
                var count = parseInt(exceptions[field]);
                if ((0, lang_1.isNaNNumber)(count)) {
                    _this.log.error("Ignoring exception with invalid count: " + exceptions[field]);
                    return;
                }
                var metadata = parsedField[0], method = parsedField[1];
                if (!result.has(metadata))
                    result.set(metadata, {});
                result.get(metadata)[method] = count;
            });
            return _this.redis.del(_this.keys.exceptionPrefix).then(function () { return result; });
        });
    };
    /**
     * Pop telemetry configs.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popConfigs = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.initPrefix).then(function (configs) {
            var result = new maps_1._Map();
            Object.keys(configs).forEach(function (field) {
                var parsedField = (0, utils_1.parseMetadata)(field);
                if ((0, lang_1.isString)(parsedField)) {
                    _this.log.error("Ignoring invalid config field: " + field + ": " + parsedField);
                    return;
                }
                var metadata = parsedField[0];
                try {
                    var config = JSON.parse(configs[field]);
                    result.set(metadata, config);
                }
                catch (e) {
                    _this.log.error("Ignoring invalid config: " + configs[field]);
                }
            });
            return _this.redis.del(_this.keys.initPrefix).then(function () { return result; });
        });
    };
    return TelemetryCacheInRedis;
}());
exports.TelemetryCacheInRedis = TelemetryCacheInRedis;
