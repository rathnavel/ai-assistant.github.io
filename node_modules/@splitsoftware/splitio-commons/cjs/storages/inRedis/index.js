"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InRedisStorage = void 0;
var KeyBuilder_1 = require("../KeyBuilder");
var KeyBuilderSS_1 = require("../KeyBuilderSS");
var SplitsCacheInRedis_1 = require("./SplitsCacheInRedis");
var SegmentsCacheInRedis_1 = require("./SegmentsCacheInRedis");
var ImpressionsCacheInRedis_1 = require("./ImpressionsCacheInRedis");
var EventsCacheInRedis_1 = require("./EventsCacheInRedis");
var constants_1 = require("../../utils/constants");
var TelemetryCacheInRedis_1 = require("./TelemetryCacheInRedis");
var UniqueKeysCacheInRedis_1 = require("./UniqueKeysCacheInRedis");
var ImpressionCountsCacheInRedis_1 = require("./ImpressionCountsCacheInRedis");
var utils_1 = require("../utils");
/**
 * InRedis storage factory for consumer server-side SplitFactory, that uses `Ioredis` Redis client for Node.
 * @see {@link https://www.npmjs.com/package/ioredis}
 */
function InRedisStorage(options) {
    if (options === void 0) { options = {}; }
    // Lazy loading to prevent error when bundling or importing the SDK in a .mjs file, since ioredis is a CommonJS module.
    // Redis storage is not supported with .mjs files.
    var RD = require('./RedisAdapter').RedisAdapter;
    var prefix = (0, KeyBuilder_1.validatePrefix)(options.prefix);
    function InRedisStorageFactory(params) {
        var onReadyCb = params.onReadyCb, settings = params.settings, _a = params.settings, log = _a.log, impressionsMode = _a.sync.impressionsMode;
        var metadata = (0, utils_1.metadataBuilder)(settings);
        var keys = new KeyBuilderSS_1.KeyBuilderSS(prefix, metadata);
        var redisClient = new RD(log, options.options || {});
        var telemetry = new TelemetryCacheInRedis_1.TelemetryCacheInRedis(log, keys, redisClient);
        var impressionCountsCache = impressionsMode !== constants_1.DEBUG ? new ImpressionCountsCacheInRedis_1.ImpressionCountsCacheInRedis(log, keys.buildImpressionsCountKey(), redisClient) : undefined;
        var uniqueKeysCache = impressionsMode === constants_1.NONE ? new UniqueKeysCacheInRedis_1.UniqueKeysCacheInRedis(log, keys.buildUniqueKeysKey(), redisClient) : undefined;
        // subscription to Redis connect event in order to emit SDK_READY event on consumer mode
        redisClient.on('connect', function () {
            onReadyCb();
            if (impressionCountsCache)
                impressionCountsCache.start();
            if (uniqueKeysCache)
                uniqueKeysCache.start();
            // Synchronize config
            telemetry.recordConfig();
        });
        return {
            splits: new SplitsCacheInRedis_1.SplitsCacheInRedis(log, keys, redisClient, settings.sync.__splitFiltersValidation),
            segments: new SegmentsCacheInRedis_1.SegmentsCacheInRedis(log, keys, redisClient),
            impressions: new ImpressionsCacheInRedis_1.ImpressionsCacheInRedis(log, keys.buildImpressionsKey(), redisClient, metadata),
            impressionCounts: impressionCountsCache,
            events: new EventsCacheInRedis_1.EventsCacheInRedis(log, keys.buildEventsKey(), redisClient, metadata),
            telemetry: telemetry,
            uniqueKeys: uniqueKeysCache,
            // When using REDIS we should:
            // 1- Disconnect from the storage
            destroy: function () {
                var promises = [];
                if (impressionCountsCache)
                    promises.push(impressionCountsCache.stop());
                if (uniqueKeysCache)
                    promises.push(uniqueKeysCache.stop());
                return Promise.all(promises).then(function () { redisClient.disconnect(); });
                // @TODO check that caches works as expected when redisClient is disconnected
            }
        };
    }
    InRedisStorageFactory.type = constants_1.STORAGE_REDIS;
    return InRedisStorageFactory;
}
exports.InRedisStorage = InRedisStorage;
