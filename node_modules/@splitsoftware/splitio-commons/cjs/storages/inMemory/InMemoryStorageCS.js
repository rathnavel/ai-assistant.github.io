"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryStorageCSFactory = void 0;
var SplitsCacheInMemory_1 = require("./SplitsCacheInMemory");
var MySegmentsCacheInMemory_1 = require("./MySegmentsCacheInMemory");
var ImpressionsCacheInMemory_1 = require("./ImpressionsCacheInMemory");
var EventsCacheInMemory_1 = require("./EventsCacheInMemory");
var ImpressionCountsCacheInMemory_1 = require("./ImpressionCountsCacheInMemory");
var constants_1 = require("../../utils/constants");
var TelemetryCacheInMemory_1 = require("./TelemetryCacheInMemory");
var UniqueKeysCacheInMemoryCS_1 = require("./UniqueKeysCacheInMemoryCS");
/**
 * InMemory storage factory for standalone client-side SplitFactory
 *
 * @param params parameters required by EventsCacheSync
 */
function InMemoryStorageCSFactory(params) {
    var _a = params.settings, _b = _a.scheduler, impressionsQueueSize = _b.impressionsQueueSize, eventsQueueSize = _b.eventsQueueSize, _c = _a.sync, impressionsMode = _c.impressionsMode, __splitFiltersValidation = _c.__splitFiltersValidation;
    var splits = new SplitsCacheInMemory_1.SplitsCacheInMemory(__splitFiltersValidation);
    var segments = new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory();
    var storage = {
        splits: splits,
        segments: segments,
        impressions: new ImpressionsCacheInMemory_1.ImpressionsCacheInMemory(impressionsQueueSize),
        impressionCounts: impressionsMode !== constants_1.DEBUG ? new ImpressionCountsCacheInMemory_1.ImpressionCountsCacheInMemory() : undefined,
        events: new EventsCacheInMemory_1.EventsCacheInMemory(eventsQueueSize),
        telemetry: (0, TelemetryCacheInMemory_1.shouldRecordTelemetry)(params) ? new TelemetryCacheInMemory_1.TelemetryCacheInMemory(splits, segments) : undefined,
        uniqueKeys: impressionsMode === constants_1.NONE ? new UniqueKeysCacheInMemoryCS_1.UniqueKeysCacheInMemoryCS() : undefined,
        // When using MEMORY we should clean all the caches to leave them empty
        destroy: function () {
            this.splits.clear();
            this.segments.clear();
            this.impressions.clear();
            this.impressionCounts && this.impressionCounts.clear();
            this.events.clear();
            this.uniqueKeys && this.uniqueKeys.clear();
        },
        // When using shared instanciation with MEMORY we reuse everything but segments (they are unique per key)
        shared: function () {
            return {
                splits: this.splits,
                segments: new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory(),
                impressions: this.impressions,
                impressionCounts: this.impressionCounts,
                events: this.events,
                telemetry: this.telemetry,
                // Set a new splits cache to clean it for the client without affecting other clients
                destroy: function () {
                    this.splits = new SplitsCacheInMemory_1.SplitsCacheInMemory(__splitFiltersValidation);
                    this.segments.clear();
                }
            };
        },
    };
    // @TODO revisit storage logic in localhost mode
    // No tracking data in localhost mode to avoid memory leaks
    if (params.settings.mode === constants_1.LOCALHOST_MODE) {
        var noopTrack = function () { return true; };
        storage.impressions.track = noopTrack;
        storage.events.track = noopTrack;
        if (storage.impressionCounts)
            storage.impressionCounts.track = noopTrack;
        if (storage.uniqueKeys)
            storage.uniqueKeys.track = noopTrack;
    }
    return storage;
}
exports.InMemoryStorageCSFactory = InMemoryStorageCSFactory;
InMemoryStorageCSFactory.type = constants_1.STORAGE_MEMORY;
