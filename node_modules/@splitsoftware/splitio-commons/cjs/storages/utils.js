"use strict";
// Shared utils for Redis and Pluggable storage
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLatencyField = exports.parseExceptionField = exports.parseMetadata = exports.impressionsToJSON = exports.metadataBuilder = void 0;
var constants_1 = require("../utils/constants");
var TelemetryCacheInMemory_1 = require("./inMemory/TelemetryCacheInMemory");
var KeyBuilderSS_1 = require("./KeyBuilderSS");
function metadataBuilder(settings) {
    return {
        s: settings.version,
        i: settings.runtime.ip || constants_1.UNKNOWN,
        n: settings.runtime.hostname || constants_1.UNKNOWN,
    };
}
exports.metadataBuilder = metadataBuilder;
// Converts impressions to be stored in Redis or pluggable storage.
function impressionsToJSON(impressions, metadata) {
    return impressions.map(function (impression) {
        var impressionWithMetadata = {
            m: metadata,
            i: {
                k: impression.keyName,
                b: impression.bucketingKey,
                f: impression.feature,
                t: impression.treatment,
                r: impression.label,
                c: impression.changeNumber,
                m: impression.time,
                pt: impression.pt,
            }
        };
        return JSON.stringify(impressionWithMetadata);
    });
}
exports.impressionsToJSON = impressionsToJSON;
// Utilities used by TelemetryCacheInRedis and TelemetryCachePluggable
var REVERSE_METHOD_NAMES = Object.keys(KeyBuilderSS_1.METHOD_NAMES).reduce(function (acc, key) {
    acc[KeyBuilderSS_1.METHOD_NAMES[key]] = key;
    return acc;
}, {});
function parseMetadata(field) {
    var parts = field.split('/');
    if (parts.length !== 3)
        return "invalid subsection count. Expected 3, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */;
    return [JSON.stringify({ s: s, n: n, i: i })];
}
exports.parseMetadata = parseMetadata;
function parseExceptionField(field) {
    var parts = field.split('/');
    if (parts.length !== 4)
        return "invalid subsection count. Expected 4, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */, m = parts[3];
    var method = REVERSE_METHOD_NAMES[m];
    if (!method)
        return "unknown method '" + m + "'";
    return [JSON.stringify({ s: s, n: n, i: i }), method];
}
exports.parseExceptionField = parseExceptionField;
function parseLatencyField(field) {
    var parts = field.split('/');
    if (parts.length !== 5)
        return "invalid subsection count. Expected 5, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */, m = parts[3], b = parts[4];
    var method = REVERSE_METHOD_NAMES[m];
    if (!method)
        return "unknown method '" + m + "'";
    var bucket = parseInt(b);
    if (isNaN(bucket) || bucket >= TelemetryCacheInMemory_1.MAX_LATENCY_BUCKET_COUNT)
        return "invalid bucket. Expected a number between 0 and " + (TelemetryCacheInMemory_1.MAX_LATENCY_BUCKET_COUNT - 1) + ", got: " + b;
    return [JSON.stringify({ s: s, n: n, i: i }), method, bucket];
}
exports.parseLatencyField = parseLatencyField;
