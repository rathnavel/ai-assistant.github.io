"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InLocalStorage = void 0;
var ImpressionsCacheInMemory_1 = require("../inMemory/ImpressionsCacheInMemory");
var ImpressionCountsCacheInMemory_1 = require("../inMemory/ImpressionCountsCacheInMemory");
var EventsCacheInMemory_1 = require("../inMemory/EventsCacheInMemory");
var KeyBuilder_1 = require("../KeyBuilder");
var KeyBuilderCS_1 = require("../KeyBuilderCS");
var isLocalStorageAvailable_1 = require("../../utils/env/isLocalStorageAvailable");
var SplitsCacheInLocal_1 = require("./SplitsCacheInLocal");
var MySegmentsCacheInLocal_1 = require("./MySegmentsCacheInLocal");
var MySegmentsCacheInMemory_1 = require("../inMemory/MySegmentsCacheInMemory");
var SplitsCacheInMemory_1 = require("../inMemory/SplitsCacheInMemory");
var browser_1 = require("../../utils/constants/browser");
var InMemoryStorageCS_1 = require("../inMemory/InMemoryStorageCS");
var constants_1 = require("./constants");
var constants_2 = require("../../utils/constants");
var TelemetryCacheInMemory_1 = require("../inMemory/TelemetryCacheInMemory");
var UniqueKeysCacheInMemoryCS_1 = require("../inMemory/UniqueKeysCacheInMemoryCS");
var key_1 = require("../../utils/key");
/**
 * InLocal storage factory for standalone client-side SplitFactory
 */
function InLocalStorage(options) {
    if (options === void 0) { options = {}; }
    var prefix = (0, KeyBuilder_1.validatePrefix)(options.prefix);
    function InLocalStorageCSFactory(params) {
        // Fallback to InMemoryStorage if LocalStorage API is not available
        if (!(0, isLocalStorageAvailable_1.isLocalStorageAvailable)()) {
            params.settings.log.warn(constants_1.LOG_PREFIX + 'LocalStorage API is unavailable. Falling back to default MEMORY storage');
            return (0, InMemoryStorageCS_1.InMemoryStorageCSFactory)(params);
        }
        var settings = params.settings, _a = params.settings, log = _a.log, _b = _a.scheduler, impressionsQueueSize = _b.impressionsQueueSize, eventsQueueSize = _b.eventsQueueSize, _c = _a.sync, impressionsMode = _c.impressionsMode, __splitFiltersValidation = _c.__splitFiltersValidation;
        var matchingKey = (0, key_1.getMatching)(settings.core.key);
        var keys = new KeyBuilderCS_1.KeyBuilderCS(prefix, matchingKey);
        var expirationTimestamp = Date.now() - browser_1.DEFAULT_CACHE_EXPIRATION_IN_MILLIS;
        var splits = new SplitsCacheInLocal_1.SplitsCacheInLocal(settings, keys, expirationTimestamp);
        var segments = new MySegmentsCacheInLocal_1.MySegmentsCacheInLocal(log, keys);
        return {
            splits: splits,
            segments: segments,
            impressions: new ImpressionsCacheInMemory_1.ImpressionsCacheInMemory(impressionsQueueSize),
            impressionCounts: impressionsMode !== constants_2.DEBUG ? new ImpressionCountsCacheInMemory_1.ImpressionCountsCacheInMemory() : undefined,
            events: new EventsCacheInMemory_1.EventsCacheInMemory(eventsQueueSize),
            telemetry: (0, TelemetryCacheInMemory_1.shouldRecordTelemetry)(params) ? new TelemetryCacheInMemory_1.TelemetryCacheInMemory(splits, segments) : undefined,
            uniqueKeys: impressionsMode === constants_2.NONE ? new UniqueKeysCacheInMemoryCS_1.UniqueKeysCacheInMemoryCS() : undefined,
            destroy: function () {
                var _a;
                this.splits = new SplitsCacheInMemory_1.SplitsCacheInMemory(__splitFiltersValidation);
                this.segments = new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory();
                this.impressions.clear();
                this.impressionCounts && this.impressionCounts.clear();
                this.events.clear();
                (_a = this.uniqueKeys) === null || _a === void 0 ? void 0 : _a.clear();
            },
            // When using shared instanciation with MEMORY we reuse everything but segments (they are customer per key).
            shared: function (matchingKey) {
                var childKeysBuilder = new KeyBuilderCS_1.KeyBuilderCS(prefix, matchingKey);
                return {
                    splits: this.splits,
                    segments: new MySegmentsCacheInLocal_1.MySegmentsCacheInLocal(log, childKeysBuilder),
                    impressions: this.impressions,
                    impressionCounts: this.impressionCounts,
                    events: this.events,
                    telemetry: this.telemetry,
                    destroy: function () {
                        this.splits = new SplitsCacheInMemory_1.SplitsCacheInMemory(__splitFiltersValidation);
                        this.segments = new MySegmentsCacheInMemory_1.MySegmentsCacheInMemory();
                    }
                };
            },
        };
    }
    InLocalStorageCSFactory.type = constants_2.STORAGE_LOCALSTORAGE;
    return InLocalStorageCSFactory;
}
exports.InLocalStorage = InLocalStorage;
