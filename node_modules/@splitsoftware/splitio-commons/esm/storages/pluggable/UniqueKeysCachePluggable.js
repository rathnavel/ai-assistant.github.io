import { __extends } from "tslib";
import { UniqueKeysCacheInMemory } from '../inMemory/UniqueKeysCacheInMemory';
import { setToArray } from '../../utils/lang/sets';
import { DEFAULT_CACHE_SIZE, REFRESH_RATE } from '../inRedis/constants';
import { LOG_PREFIX } from './constants';
var UniqueKeysCachePluggable = /** @class */ (function (_super) {
    __extends(UniqueKeysCachePluggable, _super);
    function UniqueKeysCachePluggable(log, key, wrapper, uniqueKeysQueueSize, refreshRate) {
        if (uniqueKeysQueueSize === void 0) { uniqueKeysQueueSize = DEFAULT_CACHE_SIZE; }
        if (refreshRate === void 0) { refreshRate = REFRESH_RATE; }
        var _this = _super.call(this, uniqueKeysQueueSize) || this;
        _this.log = log;
        _this.key = key;
        _this.wrapper = wrapper;
        _this.refreshRate = refreshRate;
        _this.onFullQueue = function () { _this.storeUniqueKeys(); };
        return _this;
    }
    UniqueKeysCachePluggable.prototype.storeUniqueKeys = function () {
        var _this = this;
        var featureNames = Object.keys(this.uniqueKeysTracker);
        if (!featureNames.length)
            return Promise.resolve(false);
        var uniqueKeysArray = featureNames.map(function (featureName) {
            var featureKeys = setToArray(_this.uniqueKeysTracker[featureName]);
            var uniqueKeysPayload = {
                f: featureName,
                ks: featureKeys
            };
            return JSON.stringify(uniqueKeysPayload);
        });
        this.clear();
        return this.wrapper.pushItems(this.key, uniqueKeysArray)
            .catch(function (err) {
            _this.log.error(LOG_PREFIX + "Error in uniqueKeys pipeline: " + err + ".");
            return false;
        });
    };
    UniqueKeysCachePluggable.prototype.start = function () {
        this.intervalId = setInterval(this.storeUniqueKeys.bind(this), this.refreshRate);
    };
    UniqueKeysCachePluggable.prototype.stop = function () {
        clearInterval(this.intervalId);
        return this.storeUniqueKeys();
    };
    /**
     * Async consumer API, used by synchronizer.
     * @param count number of items to pop from the queue. If not provided or equal 0, all items will be popped.
     */
    UniqueKeysCachePluggable.prototype.popNRaw = function (count) {
        var _this = this;
        if (count === void 0) { count = 0; }
        return Promise.resolve(count || this.wrapper.getItemsCount(this.key))
            .then(function (count) { return _this.wrapper.popItems(_this.key, count); })
            .then(function (uniqueKeyItems) { return uniqueKeyItems.map(function (uniqueKeyItem) { return JSON.parse(uniqueKeyItem); }); });
    };
    return UniqueKeysCachePluggable;
}(UniqueKeysCacheInMemory));
export { UniqueKeysCachePluggable };
