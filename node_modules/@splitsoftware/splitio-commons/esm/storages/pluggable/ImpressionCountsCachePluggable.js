import { __extends } from "tslib";
import { ImpressionCountsCacheInMemory } from '../inMemory/ImpressionCountsCacheInMemory';
import { REFRESH_RATE } from '../inRedis/constants';
import { LOG_PREFIX } from './constants';
var ImpressionCountsCachePluggable = /** @class */ (function (_super) {
    __extends(ImpressionCountsCachePluggable, _super);
    function ImpressionCountsCachePluggable(log, key, wrapper, impressionCountsCacheSize, refreshRate) {
        if (refreshRate === void 0) { refreshRate = REFRESH_RATE; }
        var _this = _super.call(this, impressionCountsCacheSize) || this;
        _this.log = log;
        _this.key = key;
        _this.wrapper = wrapper;
        _this.refreshRate = refreshRate;
        _this.onFullQueue = function () { _this.storeImpressionCounts(); };
        return _this;
    }
    ImpressionCountsCachePluggable.prototype.storeImpressionCounts = function () {
        var _this = this;
        var counts = this.pop();
        var keys = Object.keys(counts);
        if (!keys.length)
            return Promise.resolve(false);
        var pipeline = keys.reduce(function (pipeline, key) {
            return pipeline.then(function () { return _this.wrapper.incr(_this.key + "::" + key, counts[key]); });
        }, Promise.resolve());
        return pipeline.catch(function (err) {
            _this.log.error(LOG_PREFIX + "Error in impression counts pipeline: " + err + ".");
            return false;
        });
    };
    ImpressionCountsCachePluggable.prototype.start = function () {
        this.intervalId = setInterval(this.storeImpressionCounts.bind(this), this.refreshRate);
    };
    ImpressionCountsCachePluggable.prototype.stop = function () {
        clearInterval(this.intervalId);
        return this.storeImpressionCounts();
    };
    // Async consumer API, used by synchronizer
    ImpressionCountsCachePluggable.prototype.getImpressionsCount = function () {
        var _this = this;
        return this.wrapper.getKeysByPrefix(this.key)
            .then(function (keys) {
            return keys.length ? Promise.all(keys.map(function (key) { return _this.wrapper.get(key); }))
                .then(function (counts) {
                keys.forEach(function (key) { return _this.wrapper.del(key).catch(function () { }); });
                var pf = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var count = counts[i];
                    var keyFeatureNameAndTime = key.split('::');
                    if (keyFeatureNameAndTime.length !== 3) {
                        _this.log.error(LOG_PREFIX + "Error spliting key " + key);
                        continue;
                    }
                    var timeFrame = parseInt(keyFeatureNameAndTime[2]);
                    if (isNaN(timeFrame)) {
                        _this.log.error(LOG_PREFIX + "Error parsing time frame " + keyFeatureNameAndTime[2]);
                        continue;
                    }
                    // @ts-ignore
                    var rawCount = parseInt(count);
                    if (isNaN(rawCount)) {
                        _this.log.error(LOG_PREFIX + "Error parsing raw count " + count);
                        continue;
                    }
                    pf.push({
                        f: keyFeatureNameAndTime[1],
                        m: timeFrame,
                        rc: rawCount,
                    });
                }
                return { pf: pf };
            }) : undefined;
        });
    };
    return ImpressionCountsCachePluggable;
}(ImpressionCountsCacheInMemory));
export { ImpressionCountsCachePluggable };
