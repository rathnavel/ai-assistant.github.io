import { validatePrefix } from '../KeyBuilder';
import { KeyBuilderSS } from '../KeyBuilderSS';
import { SplitsCacheInRedis } from './SplitsCacheInRedis';
import { SegmentsCacheInRedis } from './SegmentsCacheInRedis';
import { ImpressionsCacheInRedis } from './ImpressionsCacheInRedis';
import { EventsCacheInRedis } from './EventsCacheInRedis';
import { DEBUG, NONE, STORAGE_REDIS } from '../../utils/constants';
import { TelemetryCacheInRedis } from './TelemetryCacheInRedis';
import { UniqueKeysCacheInRedis } from './UniqueKeysCacheInRedis';
import { ImpressionCountsCacheInRedis } from './ImpressionCountsCacheInRedis';
import { metadataBuilder } from '../utils';
/**
 * InRedis storage factory for consumer server-side SplitFactory, that uses `Ioredis` Redis client for Node.
 * @see {@link https://www.npmjs.com/package/ioredis}
 */
export function InRedisStorage(options) {
    if (options === void 0) { options = {}; }
    // Lazy loading to prevent error when bundling or importing the SDK in a .mjs file, since ioredis is a CommonJS module.
    // Redis storage is not supported with .mjs files.
    var RD = require('./RedisAdapter').RedisAdapter;
    var prefix = validatePrefix(options.prefix);
    function InRedisStorageFactory(params) {
        var onReadyCb = params.onReadyCb, settings = params.settings, _a = params.settings, log = _a.log, impressionsMode = _a.sync.impressionsMode;
        var metadata = metadataBuilder(settings);
        var keys = new KeyBuilderSS(prefix, metadata);
        var redisClient = new RD(log, options.options || {});
        var telemetry = new TelemetryCacheInRedis(log, keys, redisClient);
        var impressionCountsCache = impressionsMode !== DEBUG ? new ImpressionCountsCacheInRedis(log, keys.buildImpressionsCountKey(), redisClient) : undefined;
        var uniqueKeysCache = impressionsMode === NONE ? new UniqueKeysCacheInRedis(log, keys.buildUniqueKeysKey(), redisClient) : undefined;
        // subscription to Redis connect event in order to emit SDK_READY event on consumer mode
        redisClient.on('connect', function () {
            onReadyCb();
            if (impressionCountsCache)
                impressionCountsCache.start();
            if (uniqueKeysCache)
                uniqueKeysCache.start();
            // Synchronize config
            telemetry.recordConfig();
        });
        return {
            splits: new SplitsCacheInRedis(log, keys, redisClient, settings.sync.__splitFiltersValidation),
            segments: new SegmentsCacheInRedis(log, keys, redisClient),
            impressions: new ImpressionsCacheInRedis(log, keys.buildImpressionsKey(), redisClient, metadata),
            impressionCounts: impressionCountsCache,
            events: new EventsCacheInRedis(log, keys.buildEventsKey(), redisClient, metadata),
            telemetry: telemetry,
            uniqueKeys: uniqueKeysCache,
            // When using REDIS we should:
            // 1- Disconnect from the storage
            destroy: function () {
                var promises = [];
                if (impressionCountsCache)
                    promises.push(impressionCountsCache.stop());
                if (uniqueKeysCache)
                    promises.push(uniqueKeysCache.stop());
                return Promise.all(promises).then(function () { redisClient.disconnect(); });
                // @TODO check that caches works as expected when redisClient is disconnected
            }
        };
    }
    InRedisStorageFactory.type = STORAGE_REDIS;
    return InRedisStorageFactory;
}
