import { findLatencyIndex } from '../findLatencyIndex';
import { getTelemetryConfigStats } from '../../sync/submitters/telemetrySubmitter';
import { CONSUMER_MODE, STORAGE_REDIS } from '../../utils/constants';
import { isNaNNumber, isString } from '../../utils/lang';
import { _Map } from '../../utils/lang/maps';
import { MAX_LATENCY_BUCKET_COUNT, newBuckets } from '../inMemory/TelemetryCacheInMemory';
import { parseLatencyField, parseExceptionField, parseMetadata } from '../utils';
var TelemetryCacheInRedis = /** @class */ (function () {
    /**
     * Create a Telemetry cache that uses Redis as storage.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param redis  Redis client.
     */
    function TelemetryCacheInRedis(log, keys, redis) {
        this.log = log;
        this.keys = keys;
        this.redis = redis;
    }
    TelemetryCacheInRedis.prototype.recordLatency = function (method, latencyMs) {
        var _a = this.keys.buildLatencyKey(method, findLatencyIndex(latencyMs)).split('::'), key = _a[0], field = _a[1];
        return this.redis.hincrby(key, field, 1)
            .catch(function () { });
    };
    TelemetryCacheInRedis.prototype.recordException = function (method) {
        var _a = this.keys.buildExceptionKey(method).split('::'), key = _a[0], field = _a[1];
        return this.redis.hincrby(key, field, 1)
            .catch(function () { });
    };
    TelemetryCacheInRedis.prototype.recordConfig = function () {
        var _a = this.keys.buildInitKey().split('::'), key = _a[0], field = _a[1];
        var value = JSON.stringify(getTelemetryConfigStats(CONSUMER_MODE, STORAGE_REDIS));
        return this.redis.hset(key, field, value).catch(function () { });
    };
    /**
     * Pop telemetry latencies.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popLatencies = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.latencyPrefix).then(function (latencies) {
            var result = new _Map();
            Object.keys(latencies).forEach(function (field) {
                var parsedField = parseLatencyField(field);
                if (isString(parsedField)) {
                    _this.log.error("Ignoring invalid latency field: " + field + ": " + parsedField);
                    return;
                }
                var count = parseInt(latencies[field]);
                if (isNaNNumber(count)) {
                    _this.log.error("Ignoring latency with invalid count: " + latencies[field]);
                    return;
                }
                var metadata = parsedField[0], method = parsedField[1], bucket = parsedField[2];
                if (bucket >= MAX_LATENCY_BUCKET_COUNT) {
                    _this.log.error("Ignoring latency with invalid bucket: " + bucket);
                    return;
                }
                var methodLatencies = result.get(metadata) || {};
                methodLatencies[method] = methodLatencies[method] || newBuckets();
                methodLatencies[method][bucket] = count;
                result.set(metadata, methodLatencies);
            });
            return _this.redis.del(_this.keys.latencyPrefix).then(function () { return result; });
        });
    };
    /**
     * Pop telemetry exceptions.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popExceptions = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.exceptionPrefix).then(function (exceptions) {
            var result = new _Map();
            Object.keys(exceptions).forEach(function (field) {
                var parsedField = parseExceptionField(field);
                if (isString(parsedField)) {
                    _this.log.error("Ignoring invalid exception field: " + field + ": " + parsedField);
                    return;
                }
                var count = parseInt(exceptions[field]);
                if (isNaNNumber(count)) {
                    _this.log.error("Ignoring exception with invalid count: " + exceptions[field]);
                    return;
                }
                var metadata = parsedField[0], method = parsedField[1];
                if (!result.has(metadata))
                    result.set(metadata, {});
                result.get(metadata)[method] = count;
            });
            return _this.redis.del(_this.keys.exceptionPrefix).then(function () { return result; });
        });
    };
    /**
     * Pop telemetry configs.
     * The returned promise rejects if redis operations fail.
     */
    TelemetryCacheInRedis.prototype.popConfigs = function () {
        var _this = this;
        return this.redis.hgetall(this.keys.initPrefix).then(function (configs) {
            var result = new _Map();
            Object.keys(configs).forEach(function (field) {
                var parsedField = parseMetadata(field);
                if (isString(parsedField)) {
                    _this.log.error("Ignoring invalid config field: " + field + ": " + parsedField);
                    return;
                }
                var metadata = parsedField[0];
                try {
                    var config = JSON.parse(configs[field]);
                    result.set(metadata, config);
                }
                catch (e) {
                    _this.log.error("Ignoring invalid config: " + configs[field]);
                }
            });
            return _this.redis.del(_this.keys.initPrefix).then(function () { return result; });
        });
    };
    return TelemetryCacheInRedis;
}());
export { TelemetryCacheInRedis };
