// Shared utils for Redis and Pluggable storage
import { UNKNOWN } from '../utils/constants';
import { MAX_LATENCY_BUCKET_COUNT } from './inMemory/TelemetryCacheInMemory';
import { METHOD_NAMES } from './KeyBuilderSS';
export function metadataBuilder(settings) {
    return {
        s: settings.version,
        i: settings.runtime.ip || UNKNOWN,
        n: settings.runtime.hostname || UNKNOWN,
    };
}
// Converts impressions to be stored in Redis or pluggable storage.
export function impressionsToJSON(impressions, metadata) {
    return impressions.map(function (impression) {
        var impressionWithMetadata = {
            m: metadata,
            i: {
                k: impression.keyName,
                b: impression.bucketingKey,
                f: impression.feature,
                t: impression.treatment,
                r: impression.label,
                c: impression.changeNumber,
                m: impression.time,
                pt: impression.pt,
            }
        };
        return JSON.stringify(impressionWithMetadata);
    });
}
// Utilities used by TelemetryCacheInRedis and TelemetryCachePluggable
var REVERSE_METHOD_NAMES = Object.keys(METHOD_NAMES).reduce(function (acc, key) {
    acc[METHOD_NAMES[key]] = key;
    return acc;
}, {});
export function parseMetadata(field) {
    var parts = field.split('/');
    if (parts.length !== 3)
        return "invalid subsection count. Expected 3, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */;
    return [JSON.stringify({ s: s, n: n, i: i })];
}
export function parseExceptionField(field) {
    var parts = field.split('/');
    if (parts.length !== 4)
        return "invalid subsection count. Expected 4, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */, m = parts[3];
    var method = REVERSE_METHOD_NAMES[m];
    if (!method)
        return "unknown method '" + m + "'";
    return [JSON.stringify({ s: s, n: n, i: i }), method];
}
export function parseLatencyField(field) {
    var parts = field.split('/');
    if (parts.length !== 5)
        return "invalid subsection count. Expected 5, got: " + parts.length;
    var s = parts[0] /* metadata.s */, n = parts[1] /* metadata.n */, i = parts[2] /* metadata.i */, m = parts[3], b = parts[4];
    var method = REVERSE_METHOD_NAMES[m];
    if (!method)
        return "unknown method '" + m + "'";
    var bucket = parseInt(b);
    if (isNaN(bucket) || bucket >= MAX_LATENCY_BUCKET_COUNT)
        return "invalid bucket. Expected a number between 0 and " + (MAX_LATENCY_BUCKET_COUNT - 1) + ", got: " + b;
    return [JSON.stringify({ s: s, n: n, i: i }), method, bucket];
}
