import { KeyBuilder } from '../KeyBuilder';
import { IPluggableStorageWrapper } from '../types';
import { ILogger } from '../../logger/types';
import { ISplit, ISplitFiltersValidation } from '../../dtos/types';
import { AbstractSplitsCacheAsync } from '../AbstractSplitsCacheAsync';
import { ISet } from '../../utils/lang/sets';
/**
 * ISplitsCacheAsync implementation for pluggable storages.
 */
export declare class SplitsCachePluggable extends AbstractSplitsCacheAsync {
    private readonly log;
    private readonly keys;
    private readonly wrapper;
    private readonly flagSetsFilter;
    /**
     * Create a SplitsCache that uses a storage wrapper.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param wrapper  Adapted wrapper storage.
     */
    constructor(log: ILogger, keys: KeyBuilder, wrapper: IPluggableStorageWrapper, splitFiltersValidation?: ISplitFiltersValidation);
    private _decrementCounts;
    private _incrementCounts;
    private _updateFlagSets;
    /**
     * Add a given split.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., wrapper operation fails)
     */
    addSplit(name: string, split: ISplit): Promise<boolean>;
    /**
     * Add a list of splits.
     * The returned promise is resolved when the operation success
     * or rejected if it fails (e.g., wrapper operation fails)
     */
    addSplits(entries: [string, ISplit][]): Promise<boolean[]>;
    /**
     * Remove a given split.
     * The returned promise is resolved when the operation success, with a boolean indicating if the split existed or not.
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    removeSplit(name: string): Promise<boolean>;
    /**
     * Remove a list of splits.
     * The returned promise is resolved when the operation success, with a boolean array indicating if the splits existed or not.
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    removeSplits(names: string[]): Promise<void>;
    /**
     * Get split.
     * The returned promise is resolved with the split definition or null if it's not defined,
     * or rejected if wrapper operation fails.
     */
    getSplit(name: string): Promise<ISplit | null>;
    /**
     * Get list of splits.
     * The returned promise is resolved with a map of split names to their split definition or null if it's not defined,
     * or rejected if wrapper operation fails.
     */
    getSplits(names: string[]): Promise<Record<string, ISplit | null>>;
    /**
     * Get list of all split definitions.
     * The returned promise is resolved with the list of split definitions,
     * or rejected if wrapper operation fails.
     */
    getAll(): Promise<ISplit[]>;
    /**
     * Get list of split names.
     * The returned promise is resolved with the list of split names,
     * or rejected if wrapper operation fails.
     */
    getSplitNames(): Promise<string[]>;
    /**
     * Get list of feature flag names related to a given list of flag set names.
     * The returned promise is resolved with the list of feature flag names per flag set.
     * It never rejects (If there is a wrapper error for some flag set, an empty set is returned for it).
     */
    getNamesByFlagSets(flagSets: string[]): Promise<ISet<string>[]>;
    /**
     * Check traffic type existence.
     * The returned promise is resolved with a boolean indicating whether the TT exist or not.
     * In case of wrapper operation failures, the promise resolves with a true value, assuming that the TT might exist.
     * It will never be rejected.
     */
    trafficTypeExists(trafficType: string): Promise<boolean>;
    /**
     * Set till number.
     * The returned promise is resolved when the operation success,
     * or rejected if it fails (e.g., wrapper operation fails).
     */
    setChangeNumber(changeNumber: number): Promise<boolean | void>;
    /**
     * Get till number or -1 if it's not defined.
     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.
     * The promise will never be rejected.
     */
    getChangeNumber(): Promise<number>;
    clear(): Promise<boolean>;
}
