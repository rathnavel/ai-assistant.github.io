import { ImpressionDataType, EventDataType, StreamingEvent, Method, OperationType, TelemetryUsageStatsPayload, UpdatesFromSSEEnum } from '../../sync/submitters/types';
import { ISegmentsCacheSync, ISplitsCacheSync, IStorageFactoryParams, ITelemetryCacheSync } from '../types';
export declare const MAX_LATENCY_BUCKET_COUNT = 23;
export declare function newBuckets(): number[];
/**
 * Record telemetry if mode is not localhost.
 * All factory instances track telemetry on server-side, and 0.1% on client-side.
 */
export declare function shouldRecordTelemetry({ settings }: IStorageFactoryParams): boolean;
export declare class TelemetryCacheInMemory implements ITelemetryCacheSync {
    private splits?;
    private segments?;
    constructor(splits?: ISplitsCacheSync | undefined, segments?: ISegmentsCacheSync | undefined);
    private e;
    isEmpty(): boolean;
    clear(): void;
    pop(): TelemetryUsageStatsPayload;
    /** Config stats */
    private timeUntilReady?;
    getTimeUntilReady(): number | undefined;
    recordTimeUntilReady(ms: number): void;
    private timeUntilReadyFromCache?;
    getTimeUntilReadyFromCache(): number | undefined;
    recordTimeUntilReadyFromCache(ms: number): void;
    private notReadyUsage;
    getNonReadyUsage(): number;
    recordNonReadyUsage(): void;
    /** Usage stats */
    private impressionStats;
    getImpressionStats(type: ImpressionDataType): number;
    recordImpressionStats(type: ImpressionDataType, count: number): void;
    private eventStats;
    getEventStats(type: EventDataType): number;
    recordEventStats(type: EventDataType, count: number): void;
    private lastSync;
    getLastSynchronization(): Partial<Record<OperationType, number | undefined>>;
    recordSuccessfulSync(resource: OperationType, timeMs: number): void;
    private httpErrors;
    popHttpErrors(): Partial<Record<OperationType, {
        [statusCode: string]: number;
    }>>;
    recordHttpError(resource: OperationType, status: number): void;
    private httpLatencies;
    popHttpLatencies(): Partial<Record<OperationType, number[]>>;
    recordHttpLatency(resource: OperationType, latencyMs: number): void;
    private authRejections;
    popAuthRejections(): number;
    recordAuthRejections(): void;
    private tokenRefreshes;
    popTokenRefreshes(): number;
    recordTokenRefreshes(): void;
    private streamingEvents;
    popStreamingEvents(): StreamingEvent[];
    recordStreamingEvents(streamingEvent: StreamingEvent): void;
    private tags;
    popTags(): string[];
    addTag(tag: string): void;
    private sessionLength?;
    getSessionLength(): number | undefined;
    recordSessionLength(ms: number): void;
    private exceptions;
    popExceptions(): Partial<Record<Method, number>>;
    recordException(method: Method): void;
    private latencies;
    popLatencies(): Partial<Record<Method, number[]>>;
    recordLatency(method: Method, latencyMs: number): void;
    private updatesFromSSE;
    popUpdatesFromSSE(): {
        sp: number;
        ms: number;
    };
    recordUpdatesFromSSE(type: UpdatesFromSSEEnum): void;
}
