import { ISplit } from '../../dtos/types';
import { AbstractSplitsCacheSync } from '../AbstractSplitsCacheSync';
import { KeyBuilderCS } from '../KeyBuilderCS';
import { ISet } from '../../utils/lang/sets';
import { ISettings } from '../../types';
/**
 * ISplitsCacheSync implementation that stores split definitions in browser LocalStorage.
 */
export declare class SplitsCacheInLocal extends AbstractSplitsCacheSync {
    private readonly keys;
    private readonly log;
    private readonly storageHash;
    private readonly flagSetsFilter;
    private hasSync?;
    private updateNewFilter?;
    /**
     * @param {KeyBuilderCS} keys
     * @param {number | undefined} expirationTimestamp
     * @param {ISplitFiltersValidation} splitFiltersValidation
     */
    constructor(settings: ISettings, keys: KeyBuilderCS, expirationTimestamp?: number);
    private _decrementCount;
    private _decrementCounts;
    private _incrementCounts;
    /**
     * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).
     * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.
     */
    clear(): void;
    addSplit(name: string, split: ISplit): boolean;
    removeSplit(name: string): boolean;
    getSplit(name: string): any;
    setChangeNumber(changeNumber: number): boolean;
    getChangeNumber(): number;
    getSplitNames(): string[];
    trafficTypeExists(trafficType: string): boolean;
    usesSegments(): boolean;
    /**
     * Check if the splits information is already stored in browser LocalStorage.
     * In this function we could add more code to check if the data is valid.
     * @override
     */
    checkCache(): boolean;
    /**
     * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,
     *
     * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned
     */
    private _checkExpiration;
    private _checkFilterQuery;
    getNamesByFlagSets(flagSets: string[]): ISet<string>[];
    private addToFlagSets;
    private removeFromFlagSets;
    private removeNames;
}
