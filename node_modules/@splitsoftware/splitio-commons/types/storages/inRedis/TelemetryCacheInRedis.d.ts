import { ILogger } from '../../logger/types';
import { Method, MultiConfigs, MultiMethodExceptions, MultiMethodLatencies } from '../../sync/submitters/types';
import { KeyBuilderSS } from '../KeyBuilderSS';
import { ITelemetryCacheAsync } from '../types';
import type { RedisAdapter } from './RedisAdapter';
export declare class TelemetryCacheInRedis implements ITelemetryCacheAsync {
    private readonly log;
    private readonly keys;
    private readonly redis;
    /**
     * Create a Telemetry cache that uses Redis as storage.
     * @param log  Logger instance.
     * @param keys  Key builder.
     * @param redis  Redis client.
     */
    constructor(log: ILogger, keys: KeyBuilderSS, redis: RedisAdapter);
    recordLatency(method: Method, latencyMs: number): Promise<number | void>;
    recordException(method: Method): Promise<number | void>;
    recordConfig(): Promise<number | void>;
    /**
     * Pop telemetry latencies.
     * The returned promise rejects if redis operations fail.
     */
    popLatencies(): Promise<MultiMethodLatencies>;
    /**
     * Pop telemetry exceptions.
     * The returned promise rejects if redis operations fail.
     */
    popExceptions(): Promise<MultiMethodExceptions>;
    /**
     * Pop telemetry configs.
     * The returned promise rejects if redis operations fail.
     */
    popConfigs(): Promise<MultiConfigs>;
}
