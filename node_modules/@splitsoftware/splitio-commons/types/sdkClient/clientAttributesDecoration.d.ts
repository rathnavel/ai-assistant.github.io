import { SplitIO } from '../types';
import { ILogger } from '../logger/types';
/**
 * Add in memory attributes storage methods and combine them with any attribute received from the getTreatment/s call
 */
export declare function clientAttributesDecoration<TClient extends SplitIO.IClient | SplitIO.IAsyncClient>(log: ILogger, client: TClient): TClient & {
    getTreatment: (maybeKey: SplitIO.SplitKey, maybeFeatureFlagName: string, maybeAttributes?: SplitIO.Attributes | undefined) => string | SplitIO.AsyncTreatment;
    getTreatmentWithConfig: (maybeKey: SplitIO.SplitKey, maybeFeatureFlagName: string, maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.TreatmentWithConfig | SplitIO.AsyncTreatmentWithConfig;
    getTreatments: (maybeKey: SplitIO.SplitKey, maybeFeatureFlagNames: string[], maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.Treatments | SplitIO.AsyncTreatments;
    getTreatmentsWithConfig: (maybeKey: SplitIO.SplitKey, maybeFeatureFlagNames: string[], maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.TreatmentsWithConfig | SplitIO.AsyncTreatmentsWithConfig;
    getTreatmentsByFlagSets: (maybeKey: SplitIO.SplitKey, maybeFlagSets: string[], maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.Treatments | SplitIO.AsyncTreatments;
    getTreatmentsWithConfigByFlagSets: (maybeKey: SplitIO.SplitKey, maybeFlagSets: string[], maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.TreatmentsWithConfig | SplitIO.AsyncTreatmentsWithConfig;
    getTreatmentsByFlagSet: (maybeKey: SplitIO.SplitKey, maybeFlagSet: string, maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.Treatments | SplitIO.AsyncTreatments;
    getTreatmentsWithConfigByFlagSet: (maybeKey: SplitIO.SplitKey, maybeFlagSet: string, maybeAttributes?: SplitIO.Attributes | undefined) => SplitIO.TreatmentsWithConfig | SplitIO.AsyncTreatmentsWithConfig;
    track: (maybeKey: SplitIO.SplitKey, maybeTT: string, maybeEvent: string, maybeEventValue?: number | undefined, maybeProperties?: SplitIO.Properties | undefined) => boolean | Promise<boolean>;
    /**
     * Add an attribute to client's in memory attributes storage
     *
     * @param {string} attributeName Attrinute name
     * @param {string, number, boolean, list} attributeValue Attribute value
     * @returns {boolean} true if the attribute was stored and false otherways
     */
    setAttribute(attributeName: string, attributeValue: SplitIO.AttributeType): boolean;
    /**
     * Returns the attribute with the given name
     *
     * @param {string} attributeName Attribute name
     * @returns {Object} Attribute with the given name
     */
    getAttribute(attributeName: string): SplitIO.AttributeType;
    /**
     * Add to client's in memory attributes storage the attributes in 'attributes'
     *
     * @param {Object} attributes Object with attributes to store
     * @returns true if attributes were stored an false otherways
     */
    setAttributes(attributes: Record<string, Object>): boolean;
    /**
     * Return all the attributes stored in client's in memory attributes storage
     *
     * @returns {Object} returns all the stored attributes
     */
    getAttributes(): Record<string, SplitIO.AttributeType>;
    /**
     * Removes from client's in memory attributes storage the attribute with the given name
     *
     * @param {string} attributeName
     * @returns {boolean} true if attribute was removed and false otherways
     */
    removeAttribute(attributeName: string): boolean;
    /**
     * Remove all the stored attributes in the client's in memory attribute storage
     */
    clearAttributes(): boolean;
};
