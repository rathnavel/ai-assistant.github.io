{"ast":null,"code":"// Action creator\n\nimport { fetchGrpcData } from \"../gRPCClient/index\";\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nexport const GRPC_DATA_SUCCESS = \"GRPC_DATA_SUCCESS\";\nexport const GRPC_DATA_ERROR = \"GRPC_DATA_ERROR\";\nexport const grpcDataSuccess = data => ({\n  type: GRPC_DATA_SUCCESS,\n  payload: data\n});\nexport const grpcDataError = error => ({\n  type: GRPC_DATA_ERROR,\n  payload: error\n});\nasync function fetchData(host, authToken, interactionId, orgId) {\n  try {\n    // ...fetch data and process it...\n    const data = await fetchGrpcData(host, authToken, interactionId, orgId);\n    // If everything is successful, return the data\n    return data;\n  } catch (error) {\n    return {\n      error: error.message,\n      summary: null,\n      interactionDateTime: \"\"\n    };\n  }\n}\n// Define a thunk for fetching the data\nexport const fetchVASData = createAsyncThunk(\"vas/fetchData\", async ({\n  host,\n  authToken,\n  interactionId,\n  orgId\n}, {\n  dispatch,\n  rejectWithValue\n}) => {\n  try {\n    console.log(\"Fetching data\", host, authToken, interactionId, orgId);\n    // fetchGrpcData returns a Promise of VASResponse\n    const res = await fetchData(host, authToken, interactionId, orgId);\n    console.log(\"Response from fetchdata\", res);\n    return res;\n  } catch (error) {\n    console.error(\"Failed to fetch data\", error);\n    // return error message as the payload\n    return rejectWithValue(error.message);\n  }\n});\n// Define the initial state\nconst initialState = {\n  grpcData: null,\n  grpcError: null\n};\n// Create a slice with reducers to handle the actions\nconst vasSlice = createSlice({\n  name: \"vas\",\n  initialState,\n  reducers: {\n    // Define reducers if needed\n    removeVASData: state => {\n      state.grpcData = null;\n      state.grpcError = null;\n    }\n    // You could define additional reducers if necessary\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchVASData.fulfilled, (state, action) => {\n      state.grpcData = action.payload;\n      state.grpcError = null;\n    }).addCase(fetchVASData.rejected, (state, action) => {\n      state.grpcData = null;\n      state.grpcError = action.payload; // Assuming the payload is a string error message\n    });\n  }\n});\nexport const {\n  removeVASData\n} = vasSlice.actions;\nexport default vasSlice.reducer;","map":{"version":3,"names":["fetchGrpcData","createSlice","createAsyncThunk","GRPC_DATA_SUCCESS","GRPC_DATA_ERROR","grpcDataSuccess","data","type","payload","grpcDataError","error","fetchData","host","authToken","interactionId","orgId","message","summary","interactionDateTime","fetchVASData","dispatch","rejectWithValue","console","log","res","initialState","grpcData","grpcError","vasSlice","name","reducers","removeVASData","state","extraReducers","builder","addCase","fulfilled","action","rejected","actions","reducer"],"sources":["/Users/ratbalas/Documents/Projects/temp/ai-assistant.github.io/src/APIIntegrations/VASummary.ts"],"sourcesContent":["// Action creator\n\nimport { fetchGrpcData } from \"../gRPCClient/index\";\nimport { createSlice, createAsyncThunk, PayloadAction } from \"@reduxjs/toolkit\";\nimport { VASResponse, VASummary } from \"./types\";\n\nexport const GRPC_DATA_SUCCESS = \"GRPC_DATA_SUCCESS\";\nexport const GRPC_DATA_ERROR = \"GRPC_DATA_ERROR\";\n\nexport const grpcDataSuccess = (data: any) => ({\n  type: GRPC_DATA_SUCCESS,\n  payload: data\n});\n\nexport const grpcDataError = (error: any) => ({\n  type: GRPC_DATA_ERROR,\n  payload: error\n});\n\nasync function fetchData(host: string, authToken: string, interactionId: string, orgId: string): Promise<VASResponse> {\n  try {\n    // ...fetch data and process it...\n    const data = await fetchGrpcData(host, authToken, interactionId, orgId);\n    // If everything is successful, return the data\n    return data;\n  } catch (error: any) {\n    return { error: error.message, summary: null, interactionDateTime: \"\" };\n  }\n}\n// Define a thunk for fetching the data\nexport const fetchVASData = createAsyncThunk<\n  VASResponse, // Return type of the payload creator\n  { host: string; authToken: string; interactionId: string; orgId: string },\n  { rejectValue: string }\n>(\"vas/fetchData\", async ({ host, authToken, interactionId, orgId }, { dispatch, rejectWithValue }) => {\n  try {\n    console.log(\"Fetching data\", host, authToken, interactionId, orgId);\n    // fetchGrpcData returns a Promise of VASResponse\n    const res = await fetchData(host, authToken, interactionId, orgId);\n    console.log(\"Response from fetchdata\", res);\n    return res;\n  } catch (error: any) {\n    console.error(\"Failed to fetch data\", error);\n    // return error message as the payload\n    return rejectWithValue(error.message);\n  }\n});\n\ninterface VASState {\n  grpcData: VASResponse | null;\n  grpcError: string | null;\n}\n// Define the initial state\nconst initialState: VASState = {\n  grpcData: null,\n  grpcError: null\n};\n\ninterface YourApiState {\n  data: VASummary | null;\n  loading: boolean;\n  error: string | null;\n}\n// Create a slice with reducers to handle the actions\nconst vasSlice = createSlice({\n  name: \"vas\",\n  initialState,\n  reducers: {\n    // Define reducers if needed\n    removeVASData: (state) => {\n      state.grpcData = null;\n      state.grpcError = null;\n    }\n    // You could define additional reducers if necessary\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchVASData.fulfilled, (state, action: PayloadAction<VASResponse>) => {\n        state.grpcData = action.payload;\n        state.grpcError = null;\n      })\n      .addCase(fetchVASData.rejected, (state, action) => {\n        state.grpcData = null;\n        state.grpcError = action.payload as string; // Assuming the payload is a string error message\n      });\n  }\n});\n\nexport const { removeVASData } = vasSlice.actions;\nexport default vasSlice.reducer;\n\n"],"mappings":"AAAA;;AAEA,SAASA,aAAa,QAAQ,qBAAqB;AACnD,SAASC,WAAW,EAAEC,gBAAgB,QAAuB,kBAAkB;AAG/E,OAAO,MAAMC,iBAAiB,GAAG,mBAAmB;AACpD,OAAO,MAAMC,eAAe,GAAG,iBAAiB;AAEhD,OAAO,MAAMC,eAAe,GAAIC,IAAS,KAAM;EAC7CC,IAAI,EAAEJ,iBAAiB;EACvBK,OAAO,EAAEF;AACX,CAAC,CAAC;AAEF,OAAO,MAAMG,aAAa,GAAIC,KAAU,KAAM;EAC5CH,IAAI,EAAEH,eAAe;EACrBI,OAAO,EAAEE;AACX,CAAC,CAAC;AAEF,eAAeC,SAASA,CAACC,IAAY,EAAEC,SAAiB,EAAEC,aAAqB,EAAEC,KAAa,EAAwB;EACpH,IAAI;IACF;IACA,MAAMT,IAAI,GAAG,MAAMN,aAAa,CAACY,IAAI,EAAEC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC;IACvE;IACA,OAAOT,IAAI;EACb,CAAC,CAAC,OAAOI,KAAU,EAAE;IACnB,OAAO;MAAEA,KAAK,EAAEA,KAAK,CAACM,OAAO;MAAEC,OAAO,EAAE,IAAI;MAAEC,mBAAmB,EAAE;IAAG,CAAC;EACzE;AACF;AACA;AACA,OAAO,MAAMC,YAAY,GAAGjB,gBAAgB,CAI1C,eAAe,EAAE,OAAO;EAAEU,IAAI;EAAEC,SAAS;EAAEC,aAAa;EAAEC;AAAM,CAAC,EAAE;EAAEK,QAAQ;EAAEC;AAAgB,CAAC,KAAK;EACrG,IAAI;IACFC,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEX,IAAI,EAAEC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC;IACnE;IACA,MAAMS,GAAG,GAAG,MAAMb,SAAS,CAACC,IAAI,EAAEC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC;IAClEO,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEC,GAAG,CAAC;IAC3C,OAAOA,GAAG;EACZ,CAAC,CAAC,OAAOd,KAAU,EAAE;IACnBY,OAAO,CAACZ,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC5C;IACA,OAAOW,eAAe,CAACX,KAAK,CAACM,OAAO,CAAC;EACvC;AACF,CAAC,CAAC;AAMF;AACA,MAAMS,YAAsB,GAAG;EAC7BC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE;AACb,CAAC;AAOD;AACA,MAAMC,QAAQ,GAAG3B,WAAW,CAAC;EAC3B4B,IAAI,EAAE,KAAK;EACXJ,YAAY;EACZK,QAAQ,EAAE;IACR;IACAC,aAAa,EAAGC,KAAK,IAAK;MACxBA,KAAK,CAACN,QAAQ,GAAG,IAAI;MACrBM,KAAK,CAACL,SAAS,GAAG,IAAI;IACxB;IACA;EACF,CAAC;EACDM,aAAa,EAAGC,OAAO,IAAK;IAC1BA,OAAO,CACJC,OAAO,CAAChB,YAAY,CAACiB,SAAS,EAAE,CAACJ,KAAK,EAAEK,MAAkC,KAAK;MAC9EL,KAAK,CAACN,QAAQ,GAAGW,MAAM,CAAC7B,OAAO;MAC/BwB,KAAK,CAACL,SAAS,GAAG,IAAI;IACxB,CAAC,CAAC,CACDQ,OAAO,CAAChB,YAAY,CAACmB,QAAQ,EAAE,CAACN,KAAK,EAAEK,MAAM,KAAK;MACjDL,KAAK,CAACN,QAAQ,GAAG,IAAI;MACrBM,KAAK,CAACL,SAAS,GAAGU,MAAM,CAAC7B,OAAiB,CAAC,CAAC;IAC9C,CAAC,CAAC;EACN;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EAAEuB;AAAc,CAAC,GAAGH,QAAQ,CAACW,OAAO;AACjD,eAAeX,QAAQ,CAACY,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}