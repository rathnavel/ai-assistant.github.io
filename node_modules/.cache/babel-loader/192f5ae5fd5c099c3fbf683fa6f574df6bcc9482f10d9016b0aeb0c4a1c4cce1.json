{"ast":null,"code":"// Action creator\nimport{fetchGrpcData}from\"../gRPCClient/index\";import{createSlice,createAsyncThunk}from\"@reduxjs/toolkit\";export const GRPC_DATA_SUCCESS=\"GRPC_DATA_SUCCESS\";export const GRPC_DATA_ERROR=\"GRPC_DATA_ERROR\";export const grpcDataSuccess=data=>({type:GRPC_DATA_SUCCESS,payload:data});export const grpcDataError=error=>({type:GRPC_DATA_ERROR,payload:error});async function fetchData(host,authToken,interactionId,orgId){try{// ...fetch data and process it...\nconst data=await fetchGrpcData(host,authToken,interactionId,orgId);// If everything is successful, return the data\nreturn data;}catch(error){return{error:error.message,summary:null,interactionDateTime:\"\"};}}// Define a thunk for fetching the data\nexport const fetchVASData=createAsyncThunk(\"vas/fetchData\",async(_ref,_ref2)=>{let{host,authToken,interactionId,orgId}=_ref;let{dispatch,rejectWithValue}=_ref2;try{console.log(\"Fetching data\",host,authToken,interactionId,orgId);// fetchGrpcData returns a Promise of VASResponse\nconst res=await fetchData(host,authToken,interactionId,orgId);console.log(\"Response from fetchdata\",res);return res;}catch(error){console.error(\"Failed to fetch data\",error);// return error message as the payload\nreturn rejectWithValue(error.message);}});// Define the initial state\nconst initialState={grpcData:null,grpcError:null};// Create a slice with reducers to handle the actions\nconst vasSlice=createSlice({name:\"vas\",initialState,reducers:{// Define reducers if needed\nremoveVASData:state=>{state.grpcData=null;state.grpcError=null;}// You could define additional reducers if necessary\n},extraReducers:builder=>{builder.addCase(fetchVASData.fulfilled,(state,action)=>{state.grpcData=action.payload;state.grpcError=null;}).addCase(fetchVASData.rejected,(state,action)=>{state.grpcData=null;state.grpcError=action.payload;// Assuming the payload is a string error message\n});}});export const{removeVASData}=vasSlice.actions;export default vasSlice.reducer;","map":{"version":3,"names":["fetchGrpcData","createSlice","createAsyncThunk","GRPC_DATA_SUCCESS","GRPC_DATA_ERROR","grpcDataSuccess","data","type","payload","grpcDataError","error","fetchData","host","authToken","interactionId","orgId","message","summary","interactionDateTime","fetchVASData","_ref","_ref2","dispatch","rejectWithValue","console","log","res","initialState","grpcData","grpcError","vasSlice","name","reducers","removeVASData","state","extraReducers","builder","addCase","fulfilled","action","rejected","actions","reducer"],"sources":["/Users/ratbalas/Documents/Projects/temp/ai-assistant.github.io/src/APIIntegrations/VASummary.ts"],"sourcesContent":["// Action creator\n\nimport { fetchGrpcData } from \"../gRPCClient/index\";\nimport { createSlice, createAsyncThunk, PayloadAction } from \"@reduxjs/toolkit\";\nimport { VASResponse, VASummary } from \"./types\";\n\nexport const GRPC_DATA_SUCCESS = \"GRPC_DATA_SUCCESS\";\nexport const GRPC_DATA_ERROR = \"GRPC_DATA_ERROR\";\n\nexport const grpcDataSuccess = (data: any) => ({\n  type: GRPC_DATA_SUCCESS,\n  payload: data\n});\n\nexport const grpcDataError = (error: any) => ({\n  type: GRPC_DATA_ERROR,\n  payload: error\n});\n\nasync function fetchData(host: string, authToken: string, interactionId: string, orgId: string): Promise<VASResponse> {\n  try {\n    // ...fetch data and process it...\n    const data = await fetchGrpcData(host, authToken, interactionId, orgId);\n    // If everything is successful, return the data\n    return data;\n  } catch (error: any) {\n    return { error: error.message, summary: null, interactionDateTime: \"\" };\n  }\n}\n// Define a thunk for fetching the data\nexport const fetchVASData = createAsyncThunk<\n  VASResponse, // Return type of the payload creator\n  { host: string; authToken: string; interactionId: string; orgId: string },\n  { rejectValue: string }\n>(\"vas/fetchData\", async ({ host, authToken, interactionId, orgId }, { dispatch, rejectWithValue }) => {\n  try {\n    console.log(\"Fetching data\", host, authToken, interactionId, orgId);\n    // fetchGrpcData returns a Promise of VASResponse\n    const res = await fetchData(host, authToken, interactionId, orgId);\n    console.log(\"Response from fetchdata\", res);\n    return res;\n  } catch (error: any) {\n    console.error(\"Failed to fetch data\", error);\n    // return error message as the payload\n    return rejectWithValue(error.message);\n  }\n});\n\ninterface VASState {\n  grpcData: VASResponse | null;\n  grpcError: string | null;\n}\n// Define the initial state\nconst initialState: VASState = {\n  grpcData: null,\n  grpcError: null\n};\n\ninterface YourApiState {\n  data: VASummary | null;\n  loading: boolean;\n  error: string | null;\n}\n// Create a slice with reducers to handle the actions\nconst vasSlice = createSlice({\n  name: \"vas\",\n  initialState,\n  reducers: {\n    // Define reducers if needed\n    removeVASData: (state) => {\n      state.grpcData = null;\n      state.grpcError = null;\n    }\n    // You could define additional reducers if necessary\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchVASData.fulfilled, (state, action: PayloadAction<VASResponse>) => {\n        state.grpcData = action.payload;\n        state.grpcError = null;\n      })\n      .addCase(fetchVASData.rejected, (state, action) => {\n        state.grpcData = null;\n        state.grpcError = action.payload as string; // Assuming the payload is a string error message\n      });\n  }\n});\n\nexport const { removeVASData } = vasSlice.actions;\nexport default vasSlice.reducer;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}